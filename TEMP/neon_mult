// Abstrakte Funktion f체r die Vektoraddition
void vector_add(Vector* A, Vector* B, Vector* result) {
    #if defined(USE_AVX)
        vector_add_avx(A, B, result);  // AVX-spezifische Implementierung
    #elif defined(USE_NEON)
        vector_add_neon(A, B, result);  // NEON-spezifische Implementierung
    #else
        vector_add_fallback(A, B, result);  // Standard C-Implementierung
    #endif
}

// SIMD-Implementierungen
void vector_add_avx(Vector* A, Vector* B, Vector* result) {
    for (size_t i = 0; i < A->size; i += 8) {  // 8 floats pro AVX-Vektor
        __m256 vecA = _mm256_load_ps(&A->data[i]);
        __m256 vecB = _mm256_load_ps(&B->data[i]);
        __m256 vecResult = _mm256_add_ps(vecA, vecB);
        _mm256_store_ps(&result->data[i], vecResult);
    }
}

void vector_add_neon(Vector* A, Vector* B, Vector* result) {
    for (size_t i = 0; i < A->size; i += 4) {  // 4 floats pro NEON-Vektor
        float32x4_t vecA = vld1q_f32(&A->data[i]);
        float32x4_t vecB = vld1q_f32(&B->data[i]);
        float32x4_t vecResult = vaddq_f32(vecA, vecB);
        vst1q_f32(&result->data[i], vecResult);
    }
}





struct ovt_test_t {
    ovt_ulong_t x,y,z,w,a,b,c;
 };
 
 OVT_FAST_TYPE(sizeof(struct ovt_test_t) * CHAR_BIT, struct ovt_test_t,   ovt_fast_test_t);
 
 void process_bits(ovt_fast_test_t *type) {
    size_t num_chunks = type->count / 64;  // Anzahl der 64-Bit-Pakete
    size_t remaining_bits = type->count % 64;  // Restbits, die nicht in ein vollst채ndiges 64-Bit-Paket passen
 
    for (size_t i = 0; i < num_chunks; i++) {
        uint64_t chunk = 0;
        
        // Holen der 64-Bit aus den Bits
        for (size_t j = 0; j < 64; j++) {
            size_t bit_pos = i * 64 + j;
            size_t bit_value = type->bits[bit_pos].bit;  // Bitwert aus der Struktur holen
            chunk |= (bit_value << j);
        }
 
        // Verarbeite das 64-Bit-Paket (AVX2, NEON oder generische Logik)
        process_64bit_chunk(chunk);
    }
 
    // Falls noch Restbits 체brig sind
    if (remaining_bits > 0) {
        uint64_t chunk = 0;
        for (size_t j = 0; j < remaining_bits; j++) {
            size_t bit_pos = num_chunks * 64 + j;
            size_t bit_value = type->bits[bit_pos].bit;
            chunk |= (bit_value << j);
        }
        // Verarbeite das letzte, unvollst채ndige 64-Bit-Paket
        process_64bit_chunk(chunk);
    }
 }